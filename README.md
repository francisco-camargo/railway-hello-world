# Railway Hello World

In this repo I aim to deploy the simplest application possible unto a [Railway](https://railway.com/) instance.

## NeuralNine Solution

[This](https://youtu.be/2YmdkXo7iP8?si=5QKCXdAv6RJD32i-) guide by NeuralNine uses the Railway CLI via `npm`

## Railway CLI

[Docs](https://docs.railway.com/guides/cli) for using the Railway CLI.

## ChatGPT o3 Solution

### Prompt

Help me set up a "Hello, World" project for Railway. Use a Railway Empty Service. I want to run "Hello, World" via Python. I want the code to be in a GitHub repo. I want to develop the code on my laptop. I have Python installed in my laptop. If something besides Python is needed to develop the code and connect to Railway, then I want to use a Docker container on my laptop. If needed use FastAPI, do not use Flask or Django.

### Response

Below is a compact, FastAPI‑only recipe that satisfies every requirement you listed:

---

### 1 .  Local scaffold

```text
railway-hello-python/
├─ main.py
├─ requirements.txt
└─ railway.toml
```

#### main.py

```python
from fastapi import FastAPI
import uvicorn, os

app = FastAPI()

@app.get("/")
def root():
    return "Hello, World!"

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=int(os.getenv("PORT", 8000)),  # Railway injects PORT
    )
```

#### requirements.txt

```
fastapi==0.110.2
uvicorn[standard]==0.29.0
```

#### railway.toml

```toml
[deploy]
startCommand = "uvicorn main:app --host 0.0.0.0 --port $PORT"
```

`startCommand` is the same setting you’d otherwise type in the dashboard, but committed to code via *Config‑as‑Code* so every deploy is deterministic.

---

### 2 .  Put it on GitHub

```bash
git init
git add .
git commit -m "Initial FastAPI Hello World"
gh repo create your-org/railway-hello-python --public --source=. --push   # or use the GitHub web UI
```

---

### 3 .  Deploy on Railway (no local Node or Railway CLI required)

1. **In the Railway UI** click **+ New → Empty Service** and name it `hello-python`.
2. In that service’s **Settings → Source**, connect the GitHub repo you just pushed.
3. Click **Deploy**.
   * Nixpacks detects `requirements.txt`, installs Python & packages, and runs the `startCommand`.
4. When the build goes green, open the autogenerated URL—you’ll see **Hello, World!

---

### 4 .  Local development loop (Python‑only)

```bash
python -m venv .venv
source .venv/bin/activate            # .venv\Scripts\activate on Windows
pip install -r requirements.txt
uvicorn main:app --reload            # http://localhost:8000
```

Iterate → `git commit` → `git push` → automatic redeploy.

---

### 5 .  Optional Railway CLI in a Docker sandbox

Railway’s CLI is handy for tailing logs or running `railway up`, but it pulls Node/npm. If you want to keep your laptop pure‑Python, wrap it in Docker:

1. Create a **project token** in *Railway → Account → Tokens*.
2. Run:

```bash
docker run --rm -it \
  -e RAILWAY_TOKEN=<YOUR_TOKEN> \
  -v ~/.railway:/root/.railway \        # persist credentials
  -v $PWD:/workspace -w /workspace \
  ghcr.io/railwayapp/cli:latest bash
```

Inside the container:

```bash
railway link            # select the project & service
railway logs -f         # stream logs
# or
railway up              # trigger deploys from local code
```

When you exit, no extra software remains on your host—just your Python env.

---

### You’re done!

You now have:

* **FastAPI “Hello, World!”** running on Railway’s free tier.
* **Source‑controlled config** that travels with the code.
* A local dev workflow that needs only Python, plus an optional CLI neatly isolated in Docker.

Happy shipping!
